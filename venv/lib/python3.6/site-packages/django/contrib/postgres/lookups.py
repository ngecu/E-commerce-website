<<<<<<< HEAD
from django.db.models import Transform
from django.db.models.lookups import PostgresOperatorLookup
=======
from django.db.models import Lookup, Transform
from django.db.models.lookups import Exact, FieldGetDbPrepValueMixin
>>>>>>> 00b7560d221a17afc2f63807b5f895c7711d089f

from .search import SearchVector, SearchVectorExact, SearchVectorField


<<<<<<< HEAD
class DataContains(PostgresOperatorLookup):
    lookup_name = 'contains'
    postgres_operator = '@>'


class ContainedBy(PostgresOperatorLookup):
    lookup_name = 'contained_by'
    postgres_operator = '<@'


class Overlap(PostgresOperatorLookup):
    lookup_name = 'overlap'
    postgres_operator = '&&'


class HasKey(PostgresOperatorLookup):
    lookup_name = 'has_key'
    postgres_operator = '?'
    prepare_rhs = False


class HasKeys(PostgresOperatorLookup):
    lookup_name = 'has_keys'
    postgres_operator = '?&'
=======
class PostgresSimpleLookup(FieldGetDbPrepValueMixin, Lookup):
    def as_sql(self, qn, connection):
        lhs, lhs_params = self.process_lhs(qn, connection)
        rhs, rhs_params = self.process_rhs(qn, connection)
        params = tuple(lhs_params) + tuple(rhs_params)
        return '%s %s %s' % (lhs, self.operator, rhs), params


class DataContains(PostgresSimpleLookup):
    lookup_name = 'contains'
    operator = '@>'


class ContainedBy(PostgresSimpleLookup):
    lookup_name = 'contained_by'
    operator = '<@'


class Overlap(PostgresSimpleLookup):
    lookup_name = 'overlap'
    operator = '&&'


class HasKey(PostgresSimpleLookup):
    lookup_name = 'has_key'
    operator = '?'
    prepare_rhs = False


class HasKeys(PostgresSimpleLookup):
    lookup_name = 'has_keys'
    operator = '?&'
>>>>>>> 00b7560d221a17afc2f63807b5f895c7711d089f

    def get_prep_lookup(self):
        return [str(item) for item in self.rhs]


class HasAnyKeys(HasKeys):
    lookup_name = 'has_any_keys'
<<<<<<< HEAD
    postgres_operator = '?|'
=======
    operator = '?|'
>>>>>>> 00b7560d221a17afc2f63807b5f895c7711d089f


class Unaccent(Transform):
    bilateral = True
    lookup_name = 'unaccent'
    function = 'UNACCENT'


class SearchLookup(SearchVectorExact):
    lookup_name = 'search'

    def process_lhs(self, qn, connection):
        if not isinstance(self.lhs.output_field, SearchVectorField):
<<<<<<< HEAD
            config = getattr(self.rhs, 'config', None)
            self.lhs = SearchVector(self.lhs, config=config)
=======
            self.lhs = SearchVector(self.lhs)
>>>>>>> 00b7560d221a17afc2f63807b5f895c7711d089f
        lhs, lhs_params = super().process_lhs(qn, connection)
        return lhs, lhs_params


<<<<<<< HEAD
class TrigramSimilar(PostgresOperatorLookup):
    lookup_name = 'trigram_similar'
    postgres_operator = '%%'
=======
class TrigramSimilar(PostgresSimpleLookup):
    lookup_name = 'trigram_similar'
    operator = '%%'


class JSONExact(Exact):
    can_use_none_as_rhs = True

    def process_rhs(self, compiler, connection):
        result = super().process_rhs(compiler, connection)
        # Treat None lookup values as null.
        return ("'null'", []) if result == ('%s', [None]) else result
>>>>>>> 00b7560d221a17afc2f63807b5f895c7711d089f
